
Author handle: cholakov

# Panoptic Analysis

## **Analysis of the codebase**:

Semi-Fungible Position Manager is a gas-efficient Uniswap V3 position manager. It essentially replaces [Uniswap V3 Non-fungible position manager](https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol) with a Semi-fungible position manager that uses the ERC-1155 interface instead of ERC-721 wrapping up to 4-legged Uniswap V3 positions in the ERC1155 non-fungible token interface. This allows to combine several options into a single NFT to create “defined risk positions,” which then makes it easier to calculate the collateralization requirement of a set of interlinked options. This is especially useful for multi-leg option strategies that have a holistic risk-defined profile even though individual options inside of it may theoretically be exposed to infinite losses.

## **Codebase quality analysis:**

This codebase is a very strong one, looks clean and the architecture seems sound. The codebase is extensively commented, describing functions and complex logic, which helps a lot us as auditors understanding the codebase.

## **Methodology and time spent:**

I spent about 13 hours diving deep into the codebase. My approach was straightforward: visual inspection of the codebase, cross-checking with unit tests and documentation, and thinking through potential edge cases.

## **New/unexpected things:**

- The usage of the ERC-1155 interface instead of ERC-721 to combine up to 4-legged Uniswap V3 positions into a single NFT. This is the first time I've seen this and it looks very useful. It allows you to combine multiple options into a single NFT to create "defined risk positions," which makes it easier to calculate the collateralization requirement for a set of interconnected options.

## **Architecture feedback**:

- **Use of ERC1155**: Inheriting from ERC1155 for token management is a notable design choice. It allows for efficient management of multiple token types within a single contract, which is beneficial for managing positions with different characteristics.

- **Integration with Uniswap V3**: Specifically,the Panoptic protocol utilizes Uniswap v3 Liquidity Provider (LP) positions as a core primitive for trading long and short options (Explained [here](#liquidity-flow))

- **Documentation and Comments**: The contract is extensively commented, including detailed descriptions for functions and complex logic. This enhances helps a lot us as auditors to get an excellent understanding of the codebase.

## **Liquidity flow:**
**Step 1 - Adding Liquidity (long==0):**

    1. User deposits tokens into the AMM, increasing their net liquidity (T) and receiving liquidity tokens.
    2. User becomes a liquidity provider (LP), earning fees from trades.
**Step 2 - Removing Liquidity (long==1):**

    1. User withdraws tokens from the AMM, decreasing their net liquidity (T).
    2. User incurs fees for removing liquidity, reducing their net liquidity (R).

## **Gross Premia vs. Owed Premia**

### **Gross Premia**:

When a user provides liquidity, they are essentially putting their tokens up for use by other traders. In exchange for this service, the user receives a share of the fees generated by the AMM.

The amount of fees that a user earns is proportional to the amount of liquidity they provide. However, the fees are not paid out immediately. Instead, they are accumulated over time. This accumulation of fees is known as gross premia.

**How Gross Premia Works:**

Here's a simplified explanation of how gross premia works:

    1. **User provides liquidity:** A user deposits tokens into an AMM to become a liquidity provider (LP).
    2. **Fee accumulation:** The AMM generates fees from the trading activity that occurs within its liquidity pools.
    3. **Gross premia accrual:** A portion of these fees is allocated to the liquidity providers, proportional to their share of the liquidity pool.
    4. **Gross premia tracking:** The AMM maintains a running tally of the fees accumulated for each unit of liquidity provided by each LP. This tally is known as gross premia.

**Why Gross Premia is Important:**

Gross premia is an important concept for several reasons:

- **Fairness:** It ensures that liquidity providers are fairly compensated for their contributions to the AMM.
- **Transparency:** It provides users with a clear understanding of how much they have earned in fees.
- **Accountability:** It ensures that the AMM's fee distribution system is accurate and transparent.
- **User engagement:** It incentivizes users to provide liquidity to the AMM, which helps to maintain liquidity and ensure efficient market pricing.

In summary, gross premia is a crucial metric for maintaining a fair, transparent, and incentivized system of fee distribution in AMMs. It ensures that liquidity providers are fairly compensated for their contributions and that the AMM's fee distribution mechanism is accurate and well-understood.

### **Owed Premia**

Owed premia is a hypothetical measure of the fees that a liquidity provider (LP) would have earned if he don’t have removed his liquidity from the AMM, so it represents the potential earnings that a LP has forgone by withdrawing therir liquidity early.

## **Systemic risks:**

- The TokenId library's construction helper functions (prefixed with 'add') and other types do not perform extensive input validation. As a result, passing invalid or nonsensical inputs into these functions or attempting to overwrite previously allocated slots may lead to unexpected or invalid results. This is intentional, and users are expected to validate inputs before using these functions.

- In some parts the code does not follow the best practice of check-effects-interaction, where state variables are updated before any external calls are made. Doing so prevents a large class of reentrancy bugs.

- Consider implementing two-step procedure for updating protocol addresses, because a copy-paste error or a typo may end up bricking protocol functionality, or sending tokens to an address with no known private key. You can prevent that by implementing a two-step procedure for updating protocol addresses, where the recipient is set as pending, and must 'accept' the assignment by making an affirmative call.

- There are missing reentrancy guards in functions calling tokens with transfer hooks. Even if the function follows the best practice of check-effects-interaction, not using a reentrancy guard when there may be transfer hooks will open the users of this protocol up to read-only reentrancies with no way to protect against it, except by block-listing the whole protocol.

## **Testing suite**

All the code is excellent tested, with an overall line coverage percentage of 100%.

    


### Time spent:
13 hours